--- ./net-snmp-5.8/snmplib/transports/snmpUDPIPv6Domain.c	2018-04-02 23:28:08.516899798 -0700
+++ ./snmpUDPIPv6Domain.c	2018-04-02 23:34:33.068902998 -0700
@@ -88,17 +88,16 @@
  * Return a string representing the address in data, or else the "far end"
  * address if data is NULL.  
  */
 
 static char *
-netsnmp_udp6_fmtaddr(netsnmp_transport *t, const void *data, int len)
+netsnmp_udp6_fmtaddr(netsnmp_transport *t, void *data, int len)
 {
     return netsnmp_ipv6_fmtaddr("UDP/IPv6", t, data, len);
 }
 
 
-
 /*
  * You can write something into opaque that will subsequently get passed back 
  * to your send function if you like.  For instance, you might want to
  * remember where a PDU came from, so that you can send a reply there...  
  */

@@ -107,24 +106,33 @@
 netsnmp_udp6_recv(netsnmp_transport *t, void *buf, int size,
 		  void **opaque, int *olength)
 {
     int             rc = -1;
     socklen_t       fromlen = sizeof(struct sockaddr_in6);
+    netsnmp_indexed_addr_pair *addr_pair = NULL;
     struct sockaddr *from;
 
     if (t != NULL && t->sock >= 0) {
-        from = (struct sockaddr *) malloc(sizeof(struct sockaddr_in6));
-        if (from == NULL) {
+        addr_pair = (netsnmp_indexed_addr_pair *) malloc(sizeof(netsnmp_indexed_addr_pair));
+        if (addr_pair == NULL) {
             *opaque = NULL;
             *olength = 0;
             return -1;
         } else {
-            memset(from, 0, fromlen);
+            memset(addr_pair, 0, sizeof(netsnmp_indexed_addr_pair));
+			from = &addr_pair->remote_addr.sa;
         }
 
 	while (rc < 0) {
+#ifdef HAVE_IP_PKTINFO
+        socklen_t local_addr_len = sizeof(addr_pair->local_addr);
+        rc = netsnmp_udp6_recvfrom(t->sock, buf, size, from, &fromlen,
+                                  (struct sockaddr*)&(addr_pair->local_addr),
+                                  &local_addr_len, &(addr_pair->if_index));
+#else
 	  rc = recvfrom(t->sock, buf, size, 0, from, &fromlen);
+#endif 
 	  if (rc < 0 && errno != EINTR) {
 	    break;
 	  }
 	}
 
@@ -138,45 +146,56 @@
             }
         } else {
             DEBUGMSGTL(("netsnmp_udp6", "recvfrom fd %d err %d (\"%s\")\n",
 			t->sock, errno, strerror(errno)));
         }
-        *opaque = (void *) from;
-        *olength = sizeof(struct sockaddr_in6);
+        *opaque = (void *) addr_pair;
+        *olength = sizeof(netsnmp_indexed_addr_pair);
     }
     return rc;
 }
 
 
 
 static int
-netsnmp_udp6_send(netsnmp_transport *t, const void *buf, int size,
+netsnmp_udp6_send(netsnmp_transport *t, void *buf, int size,
 		  void **opaque, int *olength)
 {
     int rc = -1;
-    const struct sockaddr *to = NULL;
+    netsnmp_indexed_addr_pair *addr_pair = NULL;
+    struct sockaddr *to = NULL;
+    struct sockaddr *from = NULL;
 
     if (opaque != NULL && *opaque != NULL &&
-        *olength == sizeof(struct sockaddr_in6)) {
-        to = (const struct sockaddr *) (*opaque);
+		((*olength == sizeof(netsnmp_indexed_addr_pair) ||
+        (*olength == sizeof(struct sockaddr_in6))))) {
+        addr_pair = (netsnmp_indexed_addr_pair *) (*opaque);
     } else if (t != NULL && t->data != NULL &&
-               ((t->data_length == sizeof(struct sockaddr_in6)) ||
-                (t->data_length == sizeof(netsnmp_indexed_addr_pair)))) {
-        to = (const struct sockaddr *) (t->data);
+                (t->data_length == sizeof(netsnmp_indexed_addr_pair))) {
+        addr_pair = (netsnmp_indexed_addr_pair *) (t->data);
     }
 
+    to = &addr_pair->remote_addr.sa;
+    from = &addr_pair->local_addr.sa;
+
     if (to != NULL && t != NULL && t->sock >= 0) {
         DEBUGIF("netsnmp_udp6") {
-            char *str = netsnmp_udp6_fmtaddr(NULL, to,
-                                             sizeof(struct sockaddr_in6));
+            char *str = netsnmp_udp6_fmtaddr(NULL, (void *) addr_pair,
+                                             sizeof(netsnmp_indexed_addr_pair));
             DEBUGMSGTL(("netsnmp_udp6",
                         "send %d bytes from %p to %s on fd %d\n",
                         size, buf, str, t->sock));
             free(str);
         }
 	while (rc < 0) {
+#ifdef HAVE_IP_PKTINFO
+       rc = netsnmp_udp6_sendto(t->sock,
+            addr_pair ? from : NULL,
+            addr_pair ? addr_pair->if_index : 0, to, buf, size);
+#else
 	    rc = sendto(t->sock, buf, size, 0, to,sizeof(struct sockaddr_in6));
+#endif 
 	    if (rc < 0 && errno != EINTR) {
 		break;
 	    }
 	}
     }
--- ./net-snmp-5.8/snmplib/transports/snmpUDPBaseDomain.c	2018-04-02 23:28:08.516899798 -0700
+++ ./snmpUDPBaseDomain.c	2018-04-02 23:33:51.004902648 -0700
@@ -116,10 +116,12 @@
 enum {
 #if defined(HAVE_IP_PKTINFO)
     cmsg_data_size = sizeof(struct in_pktinfo)
 #elif defined(HAVE_IP_RECVDSTADDR)
     cmsg_data_size = sizeof(struct in_addr)
+#else
+	cmsg_data_size = sizeof(struct in6_pktinfo)
 #endif
 };
 
 #ifdef WIN32
 #ifndef WSAID_WSASENDMSG
@@ -132,10 +134,138 @@
 
 static LPFN_WSARECVMSG pfWSARecvMsg;
 static LPFN_WSASENDMSG pfWSASendMsg;
 #endif
 
+#ifdef HAVE_IP_PKTINFO
+int
+netsnmp_udp6_recvfrom(int s, void *buf, int len, struct sockaddr *from,
+                         socklen_t *fromlen, struct sockaddr *dstip,
+                         socklen_t *dstlen, int *if_index)
+{
+    int r;
+    struct iovec iov;
+    char cmsg[CMSG_SPACE(sizeof(struct in6_pktinfo))];
+    struct cmsghdr *cm;
+    struct msghdr msg;
+
+    iov.iov_base = buf;
+    iov.iov_len = len;
+
+    memset(&msg, 0, sizeof msg);
+    msg.msg_name = from;
+    msg.msg_namelen = *fromlen;
+    msg.msg_iov = &iov;
+    msg.msg_iovlen = 1;
+    msg.msg_control = &cmsg;
+    msg.msg_controllen = sizeof(cmsg);
+
+    r = recvmsg(s, &msg, MSG_DONTWAIT);
+
+    if (r == -1) {
+        return -1;
+    }
+
+    DEBUGMSGTL(("udp6:recv", "got source addr: %s\n",
+                netsnmp_ipv6_fmtaddr("UDP/IPv6", NULL, (void *)from, sizeof(struct sockaddr_in6))));
+
+
+    {
+        /* Get the local port number for use in diagnostic messages */
+        int r2 = getsockname(s, dstip, dstlen);
+        netsnmp_assert(r2 == 0);
+    }
+
+    for (cm = CMSG_FIRSTHDR(&msg); cm != NULL; cm = CMSG_NXTHDR(&msg, cm)) {
+        if (cm->cmsg_level == IPPROTO_IPV6 && cm->cmsg_type == IPV6_PKTINFO) {
+            struct in6_pktinfo* src = (struct in6_pktinfo *)CMSG_DATA(cm);
+            netsnmp_assert(dstip->sa_family == AF_INET6);
+            ((struct sockaddr_in6*)dstip)->sin6_addr = src->ipi6_addr;
+            *if_index = src->ipi6_ifindex;
+            DEBUGMSGTL(("udpbase:recv",
+                        "got destination (local) addr %s, iface %d\n",
+                        netsnmp_ipv6_fmtaddr("UDP/IPv6", NULL, (void *)dstip, sizeof(struct sockaddr_in6)),
+                        *if_index));
+        }
+    }
+    return r;
+}
+
+int netsnmp_udp6_sendto(int fd, struct sockaddr_in6 *local, int if_index,
+                           struct sockaddr_in6 *remote, void *data, int len)
+{
+    struct iovec iov;
+    struct msghdr m = { 0 };
+    char          cmsg[CMSG_SPACE(sizeof(struct in6_pktinfo))];
+    int           rc;
+
+    iov.iov_base = data;
+    iov.iov_len  = len;
+
+    m.msg_name		= remote;
+    m.msg_namelen	= sizeof(struct sockaddr_in6);
+    m.msg_iov		= &iov;
+    m.msg_iovlen	= 1;
+    m.msg_flags		= 0;
+
+    if (local) {
+        struct cmsghdr *cm;
+		char *str = netsnmp_ipv6_fmtaddr("UDP/IPv6", NULL, (void *)remote, sizeof(struct sockaddr_in6));
+
+       DEBUGMSGTL(("udp6:sendto", "sending to %s intf %d\n",
+					str, if_index));
+
+        memset(cmsg, 0, sizeof(cmsg));
+
+        m.msg_control    = &cmsg;
+        m.msg_controllen = sizeof(cmsg);
+
+        cm = CMSG_FIRSTHDR(&m);
+        cm->cmsg_len = CMSG_LEN(sizeof(struct in6_pktinfo));
+
+        cm->cmsg_level = IPPROTO_IPV6;
+        cm->cmsg_type = IPV6_PKTINFO;
+
+        {
+            struct in6_pktinfo ipi = { 0 };
+            ipi.ipi6_ifindex = 0;
+            ipi.ipi6_addr = local->sin6_addr;
+            memcpy(CMSG_DATA(cm), &ipi, sizeof(ipi));
+        }
+
+        rc = sendmsg(fd, &m, MSG_NOSIGNAL|MSG_DONTWAIT);
+        if (rc >= 0 || errno != EINVAL)
+            return rc;
+
+        /*
+         * The error might be caused by broadcast srcip (i.e. we're responding
+         * to a broadcast request) - sendmsg does not like it. Try to resend it
+         * using the interface on which it was received
+         */
+
+        DEBUGMSGTL(("udp6:sendto", "re-sending on iface %d\n", if_index));
+
+        {
+            struct in6_pktinfo ipi = { 0 };
+            ipi.ipi6_ifindex = if_index;
+            ipi.ipi6_addr = in6addr_any;
+            memcpy(CMSG_DATA(cm), &ipi, sizeof(ipi));
+        }
+        rc = sendmsg(fd, &m, MSG_NOSIGNAL|MSG_DONTWAIT);
+        if (rc >= 0 || errno != EINVAL) {
+           return rc;
+		}
+
+        DEBUGMSGTL(("udp6:sendto", "re-sending without source address\n"));
+        m.msg_control = NULL;
+        m.msg_controllen = 0;
+    }
+
+    return sendmsg(fd, &m, MSG_NOSIGNAL|MSG_DONTWAIT);
+}
+#endif
+
 int
 netsnmp_udpbase_recvfrom(int s, void *buf, int len, struct sockaddr *from,
                          socklen_t *fromlen, struct sockaddr *dstip,
                          socklen_t *dstlen, int *if_index)
 {
