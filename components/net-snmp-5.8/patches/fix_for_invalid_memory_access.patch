Patch for below net-snmp bugs
https://sourceforge.net/p/net-snmp/patches/1391/
https://sourceforge.net/p/net-snmp/bugs/2914/
=====================================================================
--- net-snmp-5.8/snmplib/snmp_api.c	2021-11-30 20:57:51.270374529 -0800
+++ net-snmp-5.8/snmplib/snmp_api.c	2021-11-30 21:19:38.076466958 -0800
@@ -350,10 +350,11 @@
 static int      snmpv3_build(u_char ** pkt, size_t * pkt_len,
                              size_t * offset, netsnmp_session * session,
                              netsnmp_pdu *pdu);
 static int      snmp_parse_version(u_char *, size_t);
 static int      snmp_resend_request(struct session_list *slp,
+				    netsnmp_request_list *orp,
                                     netsnmp_request_list *rp,
                                     int incr_retries);
 static void     register_default_handlers(void);
 static struct session_list *snmp_sess_copy(netsnmp_session * pss);
 
@@ -5715,11 +5716,11 @@
 	     * trigger immediate retry on recoverable Reports 
 	     * * (notInTimeWindow), incr_retries == TRUE to prevent
 	     * * inifinite resend                      
 	     */
 	    if (rp->retries <= sp->retries) {
-	      snmp_resend_request(slp, rp, TRUE);
+	      snmp_resend_request(slp, orp, rp, TRUE);
 	      break;
 	    } else {
 	      /* We're done with retries, so no longer waiting for a response */
 	      if (callback) {
 	        callback(NETSNMP_CALLBACK_OP_SEC_ERROR, sp,
@@ -6660,13 +6661,26 @@
         snmp_sess_timeout((void *) slp);
     }
     snmp_res_unlock(MT_LIBRARY_ID, MT_LIB_SESSION);
 }
 
+static void
+remove_request(struct snmp_internal_session *isp,
+               netsnmp_request_list *orp, netsnmp_request_list *rp)
+{
+    if (orp)
+        orp->next_request = rp->next_request;
+    else
+        isp->requests = rp->next_request;
+    if (isp->requestsEnd == rp)
+        isp->requestsEnd = orp;
+    snmp_free_pdu(rp->pdu);
+}
+
 static int
-snmp_resend_request(struct session_list *slp, netsnmp_request_list *rp,
-                    int incr_retries)
+snmp_resend_request(struct session_list *slp, netsnmp_request_list *orp,
+		netsnmp_request_list *rp, int incr_retries)
 {
     struct snmp_internal_session *isp;
     netsnmp_session *sp;
     netsnmp_transport *transport;
     u_char         *pktbuf = NULL, *packet = NULL;
@@ -6729,13 +6743,15 @@
 
     if (result < 0) {
         sp->s_snmp_errno = SNMPERR_BAD_SENDTO;
         sp->s_errno = errno;
         snmp_set_detail(strerror(errno));
-        if (rp->callback)
+        if (rp->callback) {
             rp->callback(NETSNMP_CALLBACK_OP_SEND_FAILED, sp,
                          rp->pdu->reqid, rp->pdu, rp->cb_data);
+	    remove_request(isp, orp, rp);
+	}
         return -1;
     } else {
         netsnmp_get_monotonic_clock(&now);
         tv = now;
         rp->timeM = tv;
@@ -6811,21 +6827,15 @@
                  */
                 if (callback) {
                     callback(NETSNMP_CALLBACK_OP_TIMED_OUT, sp,
                              rp->pdu->reqid, rp->pdu, magic);
                 }
-                if (orp)
-                    orp->next_request = rp->next_request;
-                else
-                    isp->requests = rp->next_request;
-                if (isp->requestsEnd == rp)
-                    isp->requestsEnd = orp;
-                snmp_free_pdu(rp->pdu);
+		remove_request(isp, orp, rp);
                 freeme = rp;
                 continue;       /* don't update orp below */
             } else {
-                if (snmp_resend_request(slp, rp, TRUE)) {
+		if (snmp_resend_request(slp, orp, rp, TRUE)) {
                     break;
                 }
             }
         }
         orp = rp;
